---
title: 零后端开发实战：用 Supabase 快速搭建你的 App
date: 2025-05-21
author: koocyton
catalog: flutter
tags:
- supabase
- flutter
header-img: /img/larsonist.jpg
---

### 前言

最近我在用 flutter 写一款记事本类 APP，
可是呢，我不太想为一款没有用户交互的 APP 准备一个服务端程序，
如果只是用户自己的文件上传和下载，
我希望能在 APP 上加密后直接传到云服务上，比如亚马逊S3，
谷歌 Firebase Store，而不用中间的服务端。
这会有些问题，用户的权限，加密，以及秘钥的存放。
最终，我使用了 Supabase 来作为数据存储。



   1. 用户注册与登录（Supabase Auth）
   2. 用户身份隔离机制（通过 UID 生成目录）
      权限规则配置确保用户只能访问自己的数据
   3. 客户端将数据数据加密后上传到 supabase storage
   4. 下载数据时客户端解密
      更新，删除

一、用户身份认证与 UID 管理

   使用 Supabase Auth，可以快速集成邮箱登录、OAuth、匿名登录等方式。
   这里就不多讲述了，只是在通过 Google 账号登录有两点需要注意和 Firebase auth不一样

   1. 需要注册一个 web 应用，拿到配置项的ID，firebase auth ,是一个 android 应用
   2. 登陆是需要将 serviceClientId 填写，才能拿到 accessToken 和 idToken 都拿到

   登录成功后，Supabase 会返回一个唯一的 user.id（也就是 UID），这是一个 UUID

```dart
    import 'package:flutter/foundation.dart';
    import 'package:google_sign_in/google_sign_in.dart';
    import 'package:supabase_flutter/supabase_flutter.dart';

    class SupabaseAuthService {

        static final GoogleSignIn _googleSignIn = GoogleSignIn(
            // Optional clientId
            scopes: <String>[
                "https://www.googleapis.com/auth/userinfo.email",
                "https://www.googleapis.com/auth/userinfo.profile",
                "email"
            ],
            serverClientId: "xxxx"
        );

        static Future<void> signIn({Function(AuthResponse)? onSuccess,Function? onFail})  async {
            // wait google signin
            final googleUser = await _googleSignIn.signIn();
            if (googleUser == null) {
            if (onFail!=null) onFail();
            return;
            }
            // get accessToken and idToken
            final googleAuth = await googleUser.authentication;
            final accessToken = googleAuth.accessToken;
            final idToken = googleAuth.idToken;
            // need set serverClientId
            if (accessToken == null || idToken == null) {
            if (onFail!=null) onFail();
            return;
            }
            // supabase auth sign
            final response = await Supabase.instance.client.auth.signInWithIdToken(
            provider: OAuthProvider.google,
            idToken: idToken,
            accessToken: accessToken
            );
            if (onSuccess!=null) {
            onSuccess(response);
            }
        }

            // sign out
        static Future<void> signOut() async {
            _googleSignIn.signOut();
            Supabase.instance.client.auth.signOut();
        }

        // static get user interface
        // User!.id is user unique id
        static User? currentUser = Supabase.instance.client.auth.currentUser;

        // on app launch , run init
        static Future<Supabase> supabaseInit() {
            return Supabase.initialize(
            url: "https://xxxx.supabase.co",
            anonKey: "xxxxxx",
            );
        }
    }
```

二、安全设计：用 UID 创建 AES 密钥与专属目录

 为了实现数据隔离和加密，我设计了以下策略：

1. 用 UID 派生用户存储目录
    每个用户登录后，我将其 UID 取 MD5 哈希值后，作为其存储目录名。例如：

    ```bash
    /notes/<md5(uid)>/<doc_uuid>.ont
    /notes/<md5(uid)>/<doc_uuid>/xxx.png
    ```

    这样做有两个好处：
    防止直接暴露用户 UID（增强安全性）
    每个用户天然拥有独立目录，便于权限隔离

2. 生成 AES 密钥用于客户端加密

    秘钥生成基本逻辑就是从用户ID为基准来获得：

    ```dart
    // create key , iv
    String md5 = EncryptUtil.saltMd5(key, hashSalt);
    String aesKey = md5.substring(0, 16);
    String aesIV = md5.substring(16, 16);
    ```

三、加密上传流程

> 在用户保存笔记时，我的做法如下：
> 将富文本内容（JSON）通过 AES 加密
> 将本地图片压缩后加密

```dart
    class StorageService {

        static Uint8List? encBytes(Uint8List data) {
            // need check currentUser null
            String? userId = SupabaseAuthService.currentUser.id;
            if (userId==null) {
                return null;
            }
            // create key , iv
            String md5 = EncryptUtil.saltMd5(key, hashSalt);
            String aesKey = md5.substring(0, 16);
            String aesIV = md5.substring(16, 16);
            return EncryptUtil.aesEncBytes(data, aesKey, aesIV);
        }

        static Uint8List? decBytes(Uint8List data) {
            // need check currentUser null
            String? userId = SupabaseAuthService.currentUser.id;
            if (userId==null) {
                return null;
            }
            // create key , iv
            String md5 = EncryptUtil.saltMd5(key, hashSalt);
            String aesKey = md5.substring(0, 16);
            String aesIV = md5.substring(16, 16);
            return EncryptUtil.aesDecBytes(data, aesKey, aesIV);
        }
    }
```

将这些加密后的内容作为字节流上传到 Supabase Storage 对应的路径

上传 API 使用 Supabase 提供的客户端 SDK，直接将加密后的内容上传为 blob 文件。

```dart
static Future<String?> uploadData({required Uint8List data, required String toUri, Map<String, dynamic>? metadata}) {
    // 加密 encrypt note
    Uint8List? encData = encBytes(data);
    if (encData!=null) {
      // load
      return SupabaseStorageService.uploadData(
        data: encData,
        toUri: toUri
      );
    }
    return Future.value(null);
  }

  static Future<String?> uploadFile({required String filePath, required String toUri, Map<String, dynamic>? metadata}) async {
    filePath = "${applicationDir}/$filePath";
    // 加密 encrypt note
    Uint8List? encData = encBytes(await XFile(filePath).readAsBytes());
    if (encData!=null) {
      return SupabaseStorageService.uploadData(
        data: encData,
        toUri: toUri
      );
    }
    return Future.value(null);
  }
```

四、解密与展示
从 Supabase Storage 下载数据时：

读取文件内容到字节流

使用用户 UID 生成相同的 AES 密钥

解密字节流，还原为原始文本或图片

加载回富文本编辑器中展示

```dart
// you all note file
static Future<List<String>> getOwnerFiles({String? dir}) {
    return SupabaseStorageService.listOwnerFilesByDir(dir:dir);
  }

// down user one file
  static Future<Uint8List?> downloadOwnerFile(String path) {
    return SupabaseStorageService.downloadOwnerFile(file:path).then((fileEncData){
        if (fileEncData!=null) {
          return _decBytes(fileEncData);
        }
        return null;
      });
  }

  static Future<void> downloadOwnerFiles({required void Function(String filePath, Uint8List fileData, int filesCount, int idx) onDownload, String? endsWith, String? dir}) async {
    List<String> files = await SupabaseStorageService.listOwnerFilesByDir(dir:dir);
    files = files.where((f)=>(endsWith!=null && f.endsWith(endsWith))).toList();
    // List<String> fileList = [];
    for (int ii=0; ii<files.length; ii++) {
      // download
      SupabaseStorageService.downloadOwnerFile(file:files[ii]).then((fileEncData){
        if (fileEncData!=null) {
          // 解密 decrypt note
          // String? noteText = _decText(utf8.decode(fileData));
          Uint8List? fileData = _decBytes(fileEncData);
          if (fileData!=null) {
            onDownload("notes/${files[ii]}", fileData, files.length, ii);
            // await CacheUtil.set("notes/${files[ii]}", noteText);
            // fileList.add(files[ii]);
          }
        }
      });
    }
    // return fileList;
  }
```

整个过程没有任何后端参与，也没有将用户的密钥或明文数据上传到云端。

五、权限配置（Supabase RLS）
为了确保安全，我在 Supabase 的 Storage 设置中配置了 访问规则（Policies）：

用户只能访问路径包含其 UID 哈希值的目录

禁止列出所有目录（防止信息泄露）

必须处于认证状态才能上传或下载

Supabase 的权限规则是基于 PostgreSQL Row Level Security（RLS）实现的，配置起来也相对直观。

总结：为什么这样设计？
安全性：所有数据均在客户端加密，Supabase 只是“文件中转站”

用户隔离：通过 UID 哈希和权限策略，用户无法访问他人数据

开发效率高：没有后端代码，全部逻辑集中在客户端

功能完整：支持登录、加密存储、图文混排、跨设备同步等功能

我会在后续更新中继续完善 AI 助手和 PDF 导出等功能，也会逐步开源核心逻辑代码，如果你也想开发一款真正意义上“无服务端”的 App，Supabase 是一个非常值得一试的方案。