<!DOCTYPE html><!--HS_IWVxCIkhkIanJO174r--><html lang="zh-CN"><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width, initial-scale=1"/><link rel="stylesheet" href="/_next/static/chunks/9988c12a819fa1cb.css" data-precedence="next"/><link rel="preload" as="script" fetchPriority="low" href="/_next/static/chunks/27f693b36b0bbdda.js"/><script src="/_next/static/chunks/82abf2d65f5428ae.js" async=""></script><script src="/_next/static/chunks/24fee8b2203ad4c2.js" async=""></script><script src="/_next/static/chunks/bd1354d7a1b1bf9d.js" async=""></script><script src="/_next/static/chunks/turbopack-389c5e9f5b0ec8cc.js" async=""></script><script src="/_next/static/chunks/7c92e96509cd355e.js" async=""></script><script src="/_next/static/chunks/bbef3146f2d34722.js" async=""></script><script src="/_next/static/chunks/ff1a16fafef87110.js" async=""></script><script src="/_next/static/chunks/d2be314c3ece3fbe.js" async=""></script><title>浅谈BeanPostProcessor加载次序及其对Bean造成的影响分析 - 一洼绿地</title><meta name="description" content="浅谈BeanPostProcessor加载次序及其对Bean造成的影响分析"/><meta name="keywords" content="javascript java php emacs spring linux flutter"/><link rel="icon" href="/img/avatar/favicon.png"/><script src="/_next/static/chunks/a6dad97d9634a72d.js" noModule=""></script></head><body class="min-h-screen flex flex-col antialiased"><div hidden=""><!--$--><!--/$--></div><header class="border-b border-[var(--color-border)]"><div class="max-w-2xl mx-auto px-5 h-12 flex items-center justify-between"><a class="font-mono text-sm font-semibold text-[var(--color-text)] hover:text-[var(--color-link)] transition-colors" href="/">一洼绿地</a><nav class="flex items-center gap-5"><a class="text-sm text-[var(--color-text-secondary)] hover:text-[var(--color-text)] transition-colors" href="/">文章</a><a class="text-sm text-[var(--color-text-secondary)] hover:text-[var(--color-text)] transition-colors" href="/archives/">归档</a><a class="text-sm text-[var(--color-text-secondary)] hover:text-[var(--color-text)] transition-colors" href="/tags/">标签</a><a class="text-sm text-[var(--color-text-secondary)] hover:text-[var(--color-text)] transition-colors" href="/about/">关于</a><a href="https://github.com/koocyton" target="_blank" rel="noopener noreferrer" class="text-[var(--color-text-tertiary)] hover:text-[var(--color-text)] transition-colors"><svg class="w-4 h-4" fill="currentColor" viewBox="0 0 24 24"><path d="M12 0c-6.626 0-12 5.373-12 12 0 5.302 3.438 9.8 8.207 11.387.599.111.793-.261.793-.577v-2.234c-3.338.726-4.033-1.416-4.033-1.416-.546-1.387-1.333-1.756-1.333-1.756-1.089-.745.083-.729.083-.729 1.205.084 1.839 1.237 1.839 1.237 1.07 1.834 2.807 1.304 3.492.997.107-.775.418-1.305.762-1.604-2.665-.305-5.467-1.334-5.467-5.931 0-1.311.469-2.381 1.236-3.221-.124-.303-.535-1.524.117-3.176 0 0 1.008-.322 3.301 1.23.957-.266 1.983-.399 3.003-.404 1.02.005 2.047.138 3.006.404 2.291-1.552 3.297-1.23 3.297-1.23.653 1.653.242 2.874.118 3.176.77.84 1.235 1.911 1.235 3.221 0 4.609-2.807 5.624-5.479 5.921.43.372.823 1.102.823 2.222v3.293c0 .319.192.694.801.576 4.765-1.589 8.199-6.086 8.199-11.386 0-6.627-5.373-12-12-12z"></path></svg></a></nav></div></header><main class="flex-1"><article class="max-w-2xl mx-auto px-5 py-10"><header class="mb-8"><h1 class="font-mono text-xl font-semibold text-[var(--color-text)] leading-tight">浅谈BeanPostProcessor加载次序及其对Bean造成的影响分析</h1><div class="flex items-center gap-3 mt-2 text-xs text-[var(--color-text-tertiary)] font-mono"><time dateTime="2024-03-28">2024-03-28</time><span>·</span><span>18 min read</span></div><div class="flex flex-wrap gap-1.5 mt-3"><a class="text-xs font-mono text-[var(--color-text-tertiary)] hover:text-[var(--color-link)] transition-colors" href="/tags/flutter/">#<!-- -->flutter</a><a class="text-xs font-mono text-[var(--color-text-tertiary)] hover:text-[var(--color-link)] transition-colors" href="/tags/app/">#<!-- -->app</a></div></header><div class="prose"><h2>前言</h2>
<p>BeanPostProcessor是一个工厂钩子，允许Spring框架在新创建Bean实例时对其进行定制化修改。例如：通过检查其标注的接口或者使用代理对其进行包裹。应用上下文会从Bean定义中自动检测出BeanPostProcessor并将它们应用到随后创建的任何Bean上。</p>
<p>普通Bean对象的工厂允许在程序中注册post-processors，应用到随后在本工厂中创建的所有Bean上。典型的场景如：post-processors使用postProcessBeforeInitialization方法通过特征接口或其他类似的方式来填充Bean；而为创建好的Bean创建代理则一般使用postProcessAfterInitialization方法。</p>
<p>BeanPostProcessor本身也是一个Bean，一般而言其实例化时机要早过普通的Bean，但是BeanPostProcessor也会依赖一些Bean，这就导致了一些Bean的实例化早于BeanPostProcessor，由此会导致一些问题。最近在处理shiro和spring cache整合时就碰到了，导致的结果就是spring cache不起作用。现将问题场景、查找历程及解决方法展现一下。</p>
<ul>
<li>1 问题场景</li>
</ul>
<p>打算在项目中将shiro与spring cache整合，使用spring cache统一管理缓存，也包括shiro认证时的用户信息查询。项目中将service分层，outter层负责权限和session，inner层主打事务和缓存并与DAO交互，两层之间也可以较容易的扩展为RPC或微服务模式。因此在shiro的authRealm中依赖了innerUserService，并在innerUserService中配置了spring cache的标注，使用cache进行缓存。配置如下（摘录重要部分）：</p>
<pre><code class="hljs language-java"><span class="hljs-meta">@Bean(name="shiroFilter")</span>
<span class="hljs-keyword">public</span> ShiroFilterFactoryBean <span class="hljs-title function_">shiroFilter</span><span class="hljs-params">(
  <span class="hljs-meta">@Qualifier("securityManager")</span> SecurityManager manager)</span> {
  ShiroFilterFactoryBean bean=<span class="hljs-keyword">new</span> <span class="hljs-title class_">ShiroFilterFactoryBean</span>();
  bean.setSecurityManager(manager);
  ..............
  <span class="hljs-keyword">return</span> bean;
}

<span class="hljs-comment">//配置核心安全事务管理器</span>
<span class="hljs-meta">@Bean(name="securityManager")</span>
<span class="hljs-keyword">public</span> SecurityManager <span class="hljs-title function_">securityManager</span><span class="hljs-params">(
                              <span class="hljs-meta">@Qualifier("authRealm")</span> AuthorizingRealm authRealm,
                              <span class="hljs-meta">@Qualifier("sessionManager")</span> SessionManager sessionManager,
                              <span class="hljs-meta">@Qualifier("cookieRememberMeManager")</span> RememberMeManager rememberMeManager,
                              <span class="hljs-meta">@Qualifier("cacheManager")</span> CacheManager cacheManager)</span> {
  System.err.println(<span class="hljs-string">"--------------shiro已经加载----------------"</span>);
  DefaultWebSecurityManager manager=<span class="hljs-keyword">new</span> <span class="hljs-title class_">DefaultWebSecurityManager</span>();
  manager.setRealm(authRealm);
  manager.setSessionManager(sessionManager);
  manager.setRememberMeManager(rememberMeManager);
  manager.setCacheManager(cacheManager);
  <span class="hljs-keyword">return</span> manager;
}

<span class="hljs-comment">//配置自定义权限登录器</span>
<span class="hljs-meta">@Bean(name="authRealm")</span>
<span class="hljs-keyword">public</span> AuthorizingRealm <span class="hljs-title function_">authRealm</span><span class="hljs-params">(IInnerUserService userService)</span> {
  <span class="hljs-type">MyRealm</span> <span class="hljs-variable">myrealm</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyRealm</span>(IInnerUserService);
  logger.info(<span class="hljs-string">"authRealm myRealm initiated!"</span>);
  <span class="hljs-keyword">return</span> myrealm;
}

<span class="hljs-meta">@Bean</span>
<span class="hljs-keyword">public</span> LifecycleBeanPostProcessor <span class="hljs-title function_">lifecycleBeanPostProcessor</span><span class="hljs-params">()</span>{
  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">LifecycleBeanPostProcessor</span>(Ordered.LOWEST_PRECEDENCE);
}
</code></pre>
<p>其中MyRealm是自定义的shiro AuthorizingRealm，用于执行认证与授权，其实现依赖innerUserService从库中查找用户信息，示例代码如下：</p>
<pre><code class="hljs language-java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyRealm</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">AuthorizingRealm</span> {

  IInnerUserService userService;

  <span class="hljs-keyword">public</span> <span class="hljs-title function_">MyRealm</span><span class="hljs-params">()</span>{
    <span class="hljs-built_in">super</span>();
  }

  <span class="hljs-keyword">public</span> <span class="hljs-title function_">MyRealm</span><span class="hljs-params">(IInnerUserService userService)</span>{
    <span class="hljs-built_in">this</span>.userService = userService;
  }

  <span class="hljs-keyword">public</span> IInnerUserService <span class="hljs-title function_">getUserService</span><span class="hljs-params">()</span> {
    <span class="hljs-keyword">return</span> userService;
  }

  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setUserService</span><span class="hljs-params">(IInnerUserService userService)</span> {
    <span class="hljs-built_in">this</span>.userService = userService;
  }

  <span class="hljs-meta">@Override</span>
  <span class="hljs-keyword">protected</span> AuthorizationInfo <span class="hljs-title function_">doGetAuthorizationInfo</span><span class="hljs-params">(
    PrincipalCollection principals)</span> {
    <span class="hljs-comment">//null usernames are invalid</span>
    <span class="hljs-keyword">if</span> (principals == <span class="hljs-literal">null</span>) {
      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AuthorizationException</span>(<span class="hljs-string">"PrincipalCollection method argument cannot be null."</span>);
    }

    <span class="hljs-type">Set</span> <span class="hljs-variable">roleNames</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashSet</span>();
    <span class="hljs-type">Set</span> <span class="hljs-variable">permissions</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashSet</span>();
    <span class="hljs-type">User</span> <span class="hljs-variable">user</span> <span class="hljs-operator">=</span> (User)getAvailablePrincipal(principals);
    roleNames.add(<span class="hljs-string">"role1"</span>);
    roleNames.add(<span class="hljs-string">"role2"</span>);
    permissions.add(<span class="hljs-string">"user:create"</span>);
    permissions.add(<span class="hljs-string">"user:update"</span>);
    permissions.add(<span class="hljs-string">"user:delete"</span>);
    <span class="hljs-type">SimpleAuthorizationInfo</span> <span class="hljs-variable">info</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SimpleAuthorizationInfo</span>(roleNames);
    info.setStringPermissions(permissions);
    <span class="hljs-keyword">return</span> info;
  }

  <span class="hljs-meta">@Override</span>
  <span class="hljs-keyword">protected</span> AuthenticationInfo <span class="hljs-title function_">doGetAuthenticationInfo</span><span class="hljs-params">(AuthenticationToken token)</span> <span class="hljs-keyword">throws</span> AuthenticationException {
    <span class="hljs-type">String</span> <span class="hljs-variable">username</span> <span class="hljs-operator">=</span> (String)token.getPrincipal(); <span class="hljs-comment">//得到用户名</span>
    <span class="hljs-type">String</span> <span class="hljs-variable">password</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>((<span class="hljs-type">char</span>[])token.getCredentials()); <span class="hljs-comment">//得到密码</span>
    <span class="hljs-type">User</span> <span class="hljs-variable">user</span> <span class="hljs-operator">=</span> userService.findByUsernameInner(username);
    <span class="hljs-keyword">if</span>(user==<span class="hljs-literal">null</span>){
      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">UnknownAccountException</span>();
    }
    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(!password.equals(user.getPassword()))
    {
      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IncorrectCredentialsException</span>();
    }
    <span class="hljs-keyword">else</span>{
      <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SimpleAuthenticationInfo</span>(user, password, getName());
    }
  }

}

而在innerUserService中配置了spring cache的标注，示例代码如下：

```java
<span class="hljs-meta">@Service</span>
  <span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">IInnerUserServiceImpl</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">IInnerUserService</span> {
  <span class="hljs-type">Logger</span> <span class="hljs-variable">logger</span> <span class="hljs-operator">=</span> LoggerFactory.getLogger(IInnerUserServiceImpl.class);

  <span class="hljs-meta">@Autowired</span>
  IUserDao userDao;

  <span class="hljs-meta">@Override</span>
  <span class="hljs-meta">@Cacheable(value = "mycache", key = "#username")</span>
  <span class="hljs-keyword">public</span> User <span class="hljs-title function_">findByUsernameInner</span><span class="hljs-params">(String username)</span> {
    <span class="hljs-type">User</span> <span class="hljs-variable">user</span> <span class="hljs-operator">=</span> userDao.findByUsername(username);
    logger.info(<span class="hljs-string">"Real execute find from database, username:{}"</span>, username);
    <span class="hljs-keyword">return</span> user;
  }
}
</code></pre>
<p>并在配置文件上标注了@EnableCaching(mode=AdviceMode.PROXY)以启动spring cache。这里不过多解释具体shiro和spring cache的使用，有兴趣的同学请自行搜索相关资料。</p>
<p>按理说这样的配置在认证的时候应该可以直接使用到innerUserService中配置的spring cache缓存。</p>
<p>但，问题出现了，当authRealm中依赖了innerUserService以后，定义在innerUserService上的spring cache就神奇的失效了。而authRealm不依赖innerUserService的时候，cache却运行的好好的。</p>
<p>接下来是问题查找的路径。</p>
<ul>
<li>
<p>2 解决问题之旅</p>
</li>
<li>
<p>2.1 spring cache失效的表象原因</p>
</li>
</ul>
<p>首先要找到spring cache失效的表象/直接原因，我们知道spring cache使用Spring AOP和拦截器的方式拦截定义了特定标注的方法，然后执行特定逻辑。因此其实现依赖于动态代理机制auto-proxy，而经过初步调试发现，当被authRealm依赖以后，innerUserService就不会被代理了，因此无从进入AOP的pointcut，也就是说AOP切面失效了！</p>
<ul>
<li>2.2 从spring cache的集成机制分析深层次原因</li>
</ul>
<p>为何没有被代理呢，我们先来确认一下正常情况下什么时候进行代理封装，这时关于BeanPostProcessor的定义浮现脑海，据文档记载BeanPostProcessor允许在Bean实例化的前后对其做一些猥琐的事情，比如代理。我们在BeanPostProcessor的实现类中发现了InstantiationAwareBeanPostProcessor、SmartInstantiationAwareBeanPostProcessor、AbstractAutoProxyCreator、InfrastructureAdvisorAutoProxyCreator这一脉。而反观@enableCache标注在启动的时候会@import CachingConfigurationSelector，其selectImports方法会返回AutoProxyRegistrar和ProxyCachingConfiguration的全类名（我们定义了mode=AdviceMode.PROXY），也就是加载这两个类。第一个的作用就是注册InfrastructureAdvisorAutoProxyCreator到BeanDefinitionRegistry中。第二个的作用就是注册了BeanFactoryCacheOperationSourceAdvisor和CacheInterceptor。</p>
<p>因此，当正常情况下，一个添加了spring cache相关标注的bean会在创建后被InfrastructureAdvisorAutoProxyCreator基于advisor进行代理增强，代理后便可在拦截器CacheInterceptor中对其方法进行拦截，然后执行cache相关逻辑。此处省略具体处理逻辑，有兴趣请参考相关文档。</p>
<p>所以第一怀疑就是innerUserService没有经过InfrastructureAdvisorAutoProxyCreator的代理增强。果然调试发现，被authRealm依赖的情况下在InnerUserService的Bean实例化时，用于处理该Bean的PostBeanProcessor明显比没被authRealm依赖时少，并且不含有InfrastructureAdvisorAutoProxyCreator。</p>
<p>而且，被依赖时会多打出来一行信息：</p>
<p>...................</p>
<p>Bean 'IInnerUserServiceImpl' of type [shiro.web.inner.service.impl.IInnerUserServiceImpl] is not eligible for getting processed by all BeanPostProcessors (for example: not eligible for auto-proxying)</p>
<p>...................</p>
<p>据此推断，可能是innerUserService启动时机过早，导致的后面那些BeanPostProcessor们来没来得及实例化及注册呢。</p>
<p>2.3 BeanPostProcessor启动阶段对其依赖的Bean造成的影响</p>
<p>首先确认了authRealm也是受害者，因为shiroFilter->SecurityManager->authRealm的依赖关系导致其不得不提前实例化。表面上的罪魁祸首是shiroFilter，但是到底是谁导致的shiroFilter预料之外的提前启动呢。shiroFilter与InfrastructureAdvisorAutoProxyCreator的具体启动时机到底是什么时候呢。</p>
<p>又经过一番混天暗地的调试，终于了解了BeanPostProcessor的启动时机。在AbstractBeanFactory中维护了BeanPostProcessor的列表：</p>
<p>private final List beanPostProcessors = new ArrayList();</p>
<p>并实现了ConfigurableBeanFactory定义的方法：</p>
<p>void addBeanPostProcessor(BeanPostProcessor beanPostProcessor);</p>
<p>因此我们首先监控AbstractBeanFactory.addBeanPostProcessor()，看看启动过程中谁调用了该方法来注册BeanPostProcessor。发现实例化及注册PostBeanFactory的阶段分为四个：</p>
<p>第一阶段是在启动时调用过程会调用AbstractApplicationContext.refresh()，其中的prepareBeanFactory方法中注册了</p>
<pre><code class="hljs language-java">ApplicationContextAwareProcessor、ApplicationListenerDetector：

........

beanFactory.addBeanPostProcessor(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ApplicationContextAwareProcessor</span>(<span class="hljs-built_in">this</span>));

........

beanFactory.addBeanPostProcessor(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ApplicationListenerDetector</span>(<span class="hljs-built_in">this</span>));

........
</code></pre>
<p>然后在postProcessBeanFactory方法中注册了WebApplicationContextServletContextAwareProcessor：</p>
<p>beanFactory.addBeanPostProcessor(</p>
<p>new WebApplicationContextServletContextAwareProcessor(this));</p>
<p>然后在invokeBeanFactoryPostProcessors方法中调用</p>
<p>复制代码 代码如下:</p>
<p>PostProcessorRegistrationDelegate.invokeBeanFactoryPostProcessors(beanFactory, getBeanFactoryPostProcessors());</p>
<p>其中对已经注册的BeanFactoryPostProcessors挨个调用其postProcessBeanFactory方法，其中有一个ConfigurationClassPostProcessor，其postProcessBeanFactory方法中注册了一个</p>
<pre><code class="hljs language-java">ImportAwareBeanPostProcessor：
beanFactory.addBeanPostProcessor(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ImportAwareBeanPostProcessor</span>(beanFactory));
</code></pre>
<p>最后在registerBeanPostProcessors方法中调用</p>
<pre><code class="hljs language-java">PostProcessorRegistrationDelegate.registerBeanPostProcessors(beanFactory, <span class="hljs-built_in">this</span>);
</code></pre>
<p>在该方法中，首先注册BeanPostProcessorChecker：</p>
<p>复制代码 代码如下:</p>
<pre><code class="hljs language-java">beanFactory.addBeanPostProcessor(<span class="hljs-keyword">new</span> <span class="hljs-title class_">BeanPostProcessorChecker</span>(beanFactory, beanProcessorTargetCount));
</code></pre>
<p>该BeanPostProcessorChecker就是输出上面那行信息的真凶，它会在Bean创建完后检查可在当前Bean上起作用的BeanPostProcessor个数与总的BeanPostProcessor个数，如果起作用的个数少于总数，则报出上面那句信息。</p>
<p>然后分成三个阶段依次实例化并注册实现了PriorityOrdered的BeanPostProcessor、实现了Ordered的BeanPostProcessor、没实现Ordered的BeanPostProcessor，代码如下：</p>
<pre><code class="hljs language-java"><span class="hljs-comment">// Separate between BeanPostProcessors that implement PriorityOrdered,</span>
<span class="hljs-comment">// Ordered, and the rest.</span>
<span class="hljs-type">List</span> <span class="hljs-variable">priorityOrderedPostProcessors</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>();
<span class="hljs-type">List</span> <span class="hljs-variable">internalPostProcessors</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>();
<span class="hljs-type">List</span> <span class="hljs-variable">orderedPostProcessorNames</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>();
<span class="hljs-type">List</span> <span class="hljs-variable">nonOrderedPostProcessorNames</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>();
<span class="hljs-keyword">for</span> (String ppName : postProcessorNames) {
  <span class="hljs-keyword">if</span> (beanFactory.isTypeMatch(ppName, PriorityOrdered.class)) {
    <span class="hljs-type">BeanPostProcessor</span> <span class="hljs-variable">pp</span> <span class="hljs-operator">=</span> beanFactory.getBean(ppName, BeanPostProcessor.class);
    priorityOrderedPostProcessors.add(pp);
    <span class="hljs-keyword">if</span> (pp <span class="hljs-keyword">instanceof</span> MergedBeanDefinitionPostProcessor) {
      internalPostProcessors.add(pp);
    }
  }
  <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (beanFactory.isTypeMatch(ppName, Ordered.class)) {
    orderedPostProcessorNames.add(ppName);
  }
  <span class="hljs-keyword">else</span> {
    nonOrderedPostProcessorNames.add(ppName);
  }
}

<span class="hljs-comment">// First, register the BeanPostProcessors that implement PriorityOrdered.</span>

sortPostProcessors(priorityOrderedPostProcessors, beanFactory);

registerBeanPostProcessors(beanFactory, priorityOrderedPostProcessors);

<span class="hljs-comment">// Next, register the BeanPostProcessors that implement Ordered.</span>

<span class="hljs-type">List</span> <span class="hljs-variable">orderedPostProcessors</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>();

<span class="hljs-keyword">for</span> (String ppName : orderedPostProcessorNames) {

  <span class="hljs-type">BeanPostProcessor</span> <span class="hljs-variable">pp</span> <span class="hljs-operator">=</span> beanFactory.getBean(ppName, BeanPostProcessor.class);

  orderedPostProcessors.add(pp);

  <span class="hljs-keyword">if</span> (pp <span class="hljs-keyword">instanceof</span> MergedBeanDefinitionPostProcessor) {

    internalPostProcessors.add(pp);

  }

}

sortPostProcessors(orderedPostProcessors, beanFactory);

registerBeanPostProcessors(beanFactory, orderedPostProcessors);

<span class="hljs-comment">// Now, register all regular BeanPostProcessors.</span>

<span class="hljs-type">List</span> <span class="hljs-variable">nonOrderedPostProcessors</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>();

<span class="hljs-keyword">for</span> (String ppName : nonOrderedPostProcessorNames) {

  <span class="hljs-type">BeanPostProcessor</span> <span class="hljs-variable">pp</span> <span class="hljs-operator">=</span> beanFactory.getBean(ppName, BeanPostProcessor.class);

  nonOrderedPostProcessors.add(pp);

  <span class="hljs-keyword">if</span> (pp <span class="hljs-keyword">instanceof</span> MergedBeanDefinitionPostProcessor) {

    internalPostProcessors.add(pp);

  }

}

registerBeanPostProcessors(beanFactory, nonOrderedPostProcessors);

<span class="hljs-comment">// Finally, re-register all internal BeanPostProcessors.</span>

sortPostProcessors(internalPostProcessors, beanFactory);

registerBeanPostProcessors(beanFactory, internalPostProcessors);

<span class="hljs-comment">// Re-register post-processor for detecting inner beans as ApplicationListeners,</span>

<span class="hljs-comment">// moving it to tCuyNowSqhe end of the processor chain (for picking up proxies etc).</span>

beanFactory.addBeanPostProcessor(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ApplicationListenerDetector</span>(applicationContext));
</code></pre>
<p>需要注意的是，除了第一个阶段，其他阶段同一个阶段的BeanPostProcessor是在全部实例化完成以后才会统一注册到beanFactory的，因此，同一个阶段的BeanPostProcessor及其依赖的Bean在实例化的时候是无法享受到相同阶段但是先实例化的BeanPostProcessor的“服务”的，因为它们还没有注册。</p>
<p>从上面调试与源代码分析，BeanPostProcessor的实例化与注册分为四个阶段，第一阶段applicationContext内置阶段、第二阶段priorityOrdered阶段、第三阶段Ordered阶段、第四阶段nonOrdered阶段。而BeanPostProcessor同时也是Bean，其注册之前一定先实例化。而且是分批实例化和注册，也就是属于同一批的BeanPostProcesser全部实例化完成后，再全部注册，不存在先实例化先注册的问题。而在实例化的时候其依赖的Bean同样要先实例化。</p>
<p>因此导致一个结果就是，被PriorityOrderedBeanPostProcessor所依赖的Bean其初始化时无法享受到PriorityOrdered、Ordered、和nonOrdered的BeanPostProcessor的服务。而被OrderedBeanPostProcessor所依赖的Bean无法享受Ordered、和nonOrdered的BeanPostProcessor的服务。最后被nonOrderedBeanPostProcessor所依赖的Bean无法享受到nonOrderedBeanPostProcessor的服务。</p>
<p>由于InfrastructureAdvisorAutoProxyCreator的启动阶段是Ordered，因此我们需要确保没有任何priorityOrdered和Ordered的BeanPostProcessor直接或间接的依赖到shiroFilter，也就是依赖到我们的innerUserService。</p>
<p>同时，在PriorityOrdered接口的注解中也提到了该情况：</p>
<p>Note: {@code PriorityOrdered} post-processor beans are initialized in</p>
<ul>
<li>
<p>a special phase, ahead of other post-processor beans. This subtly</p>
</li>
<li>
<p>affects their auhttp://towiring behavior: they will only be autowired against</p>
</li>
<li>
<p>beans which do not require eager initialization for type matching.</p>
</li>
</ul>
<p>2.4 BeanPostProcessor在进行依赖的Bean注入时，根据Bean名称进行类型检查时导致的“误伤”</p>
<p>OK，问题貌似已查明，修改Configuration中所有PriorityOrdered和Ordered类型的PostBeanProcessor的Bean配置，使其不再依赖shiroFilter。再次启动，却发现仍然提前启动了shiroFilter->SecurityManager->authRealm->innerUserService。</p>
<p>百思不得其解，又是一轮昏天暗地的调试，查找shiroFilter具体的启动时机。发现在一个叫做dataSourceInitializerPostProcessor的BeanPostProcessor实例化的时候，在根据类型获得其依赖的参数时，对shiroFilter执行了初始化。导致后续SecurityManager->authRealm->innerUserService统统提前初始化。但是在dataSourceInitializerPostProcessor之前的BeanPostProcessor却没有。经调试它们是否会导致shiroFilter初始化的区别在调用AbstractBeanFactory.isTypeMatch方法时出现：</p>
<pre><code class="hljs language-java"><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isTypeMatch</span><span class="hljs-params">(String name, ResolvableType typeToMatch)</span> <span class="hljs-keyword">throws</span> NoSuchBeanDefinitionException{

.....................

<span class="hljs-comment">// Check bean class whether we're dealing with a FactoryBean.</span>

<span class="hljs-keyword">if</span> (FactoryBean.class.isAssignableFrom(beanType)) { <span class="hljs-comment">//（1）判断名称对应的Bean是否是一个FactoryBean，若是FactoryBean才执行本句</span>

<span class="hljs-keyword">if</span> (!BeanFactoryUtils.isFactoryDereference(name)) {

<span class="hljs-comment">// If it's a FactoryBean, we want to look at what it creates, not the factory class.</span>

beanType = getTypeForFactoryBean(beanName, mbd);

<span class="hljs-keyword">if</span> (beanType == <span class="hljs-literal">null</span>) {

<span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;

}

}

}

.....................

}
</code></pre>
<p>然后进入AbstractAutowireCapableBeanFactory.getTypeForFactoryBean方法：</p>
<pre><code class="hljs language-java"><span class="hljs-meta">@Override</span>

<span class="hljs-keyword">protected</span> Class> getTypeForFactoryBean(String beanName, RootBeanDefinition mbd) {

<span class="hljs-type">String</span> <span class="hljs-variable">factoryBeanName</span> <span class="hljs-operator">=</span> mbd.getFactoryBeanName();

<span class="hljs-type">String</span> <span class="hljs-variable">factoryMethodName</span> <span class="hljs-operator">=</span> mbd.getFactoryMethodName();

<span class="hljs-keyword">if</span> (factoryBeanName != <span class="hljs-literal">null</span>) {

<span class="hljs-keyword">if</span> (factoryMethodName != <span class="hljs-literal">null</span>) {

<span class="hljs-comment">// Try to obtain the FactoryBean's object type from its factory method declaration</span>

<span class="hljs-comment">// without instantiating the containing bean at all.</span>

BeanDefihttp:<span class="hljs-comment">//nition fbDef = getBeanDefinition(factoryBeanName);</span>

<span class="hljs-keyword">if</span> (fbDef <span class="hljs-keyword">instanceof</span> AbstractBeanDefinition) {

<span class="hljs-type">AbstractBeanDefinition</span> <span class="hljs-variable">afbDef</span> <span class="hljs-operator">=</span> (AbstractBeanDefinition) fbDef;

<span class="hljs-keyword">if</span> (afbDef.hasBeanClass()) {

Class> result = getTypeForFactoryBeanFromMethod(afbDef.getBeanClass(), factoryMethodName);

<span class="hljs-keyword">if</span> (result != <span class="hljs-literal">null</span>) {

<span class="hljs-keyword">return</span> result;

}

}

}

}

<span class="hljs-comment">// If not resolvable above and the referenced factory bean doesn't exist yet,</span>

<span class="hljs-comment">// exit here - we don't want to force the creation of another bean just to</span>

<span class="hljs-comment">// obtain a FactoryBean's object type...</span>

<span class="hljs-keyword">if</span> (!isBeanEligibleForMetadataCaching(factoryBeanName)) { <span class="hljs-comment">//（2）判断该bean对应的factoryBeanName是否已经初始化了，如果没有，就返回。如果有，则继续</span>

<span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;

}

}

<span class="hljs-comment">// Let's obtain a shortcut instance for an early getObjectType() call...</span>

FactoryBean> fb = (mbd.isSingleton() ?

getSingletonFactoryBeanForTypeCheck(beanName, mbd) :

getNonSingletonFactoryBeanForTypeCheck(beanName, mbd));

......................

}
</code></pre>
<p>其中，有一个重要的判断：</p>
<pre><code class="hljs language-java"><span class="hljs-comment">// If not resolvable above and the referenced factory bean doesn't exist yet,</span>

<span class="hljs-comment">// exit here - we don't want to force the creation of another bean just to</span>

<span class="hljs-comment">// obtain a FactoryBean's object type...</span>

<span class="hljs-keyword">if</span> (!isBeanEligibleForMetadataCaching(factoryBeanName)) {

<span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;

}
</code></pre>
<p>注解说的很明确，如果名字对应的factoryBean所在的factoryBean工厂尚未解析并实例化，那就直接退出，不会强制创建该facotryBean工厂，也就是Configuration对应的Bean。再次调试，果然发现，在先前的BeanPostProcessor和dataSourceInitializerPostProcessor之间，存在一个lifecycleBeanPostProcessor，而lifecycleBeanPostProcessor是在我们的Configuration中显示定义的，因此，当lifecycleBeanPostProcessor启动时会导致Configuration实例化。</p>
<p>dataSourceInitializerPostProcessor和在它之前的BeanPostProcessor对shiroFilter行为的不同在这里得到了完美的解释。本质上说dataSourceInitializerPostProcessor并不重要，重要的是lifecycleBeanPostProcessor将Configuration初始化了。就算不是dataSourceInitializerPostProcessor，那另一个BeanPostProcessor实例化时同样会将shiroFilter初始化。</p>
<p>最终隐藏大BOSS查明，解决方案就简单了，将lifecycleBeanPostProcessor移出到一个单独的Configuration就好了。</p>
<ol>
<li>总结</li>
</ol>
<p>3.1 BeanPostProcessor启动顺序，以及其对于依赖的Bean的影响</p>
<p>BeanPostProcessor的启动时机。分为四个阶段，第一阶段context内置阶段、第二阶段priorityOrdered阶段、第三阶段Ordered阶段、第四阶段nonOrdered阶段。</p>
<p>而BeanPostProcessor同时也是Bean，其注册之前一定先实例化。而且是分批实例化和注册，也就是属于同一批的BeanPostProcesser全部实例化完成后，再全部注册，不存在先实例化先注册的问题。而在实例化的时候其依赖的Bean同样要先实例化。</p>
<p>因此导致一个结果就是，被PriorityOrderedBeanPostProcessor所依赖的Bean其初始化以后无法享受到PriorityOrdered、Ordered、和nonOrdered的BeanPostProcessor的服务。而被OrderedBeanPostProcessor所依赖的Bean无法享受Ordered、和nonOrdered的BeanPostProcessor的服务。最后被nonOrderedBeanPostProcessor所依赖的Bean无法享受到nonOrderedBeanPostProcessor的服务。</p>
<p>3.2 注意避免BeanPostProcessor启动时的“误伤”陷阱</p>
<p>BeanPostProcessor实例化时，自动依赖注入根据类型获得需要注入的Bean时，会将某些符合条件的Bean（FactoryBean并且其FactoryBeanFactory已经实例化的）先实例化，如果此FacotryBean又依赖其他普通Bean，会导致该Bean提前启动，造成误伤（无法享受部分BeanPostProcessor的后处理，例如典型的auto-proxy）。</p></div><div class="mt-12 pt-6 border-t border-[var(--color-border)]"><div></div></div><footer class="mt-8 pt-4 border-t border-[var(--color-border)]"><a class="text-sm text-[var(--color-link)] hover:underline" href="/">← 返回</a></footer></article><!--$--><!--/$--></main><footer class="border-t border-[var(--color-border)] py-6"><div class="max-w-2xl mx-auto px-5 text-xs text-[var(--color-text-tertiary)]">© <!-- -->2026<!-- --> koocyton</div></footer><script src="/_next/static/chunks/27f693b36b0bbdda.js" id="_R_" async=""></script><script>(self.__next_f=self.__next_f||[]).push([0])</script><script>self.__next_f.push([1,"1:\"$Sreact.fragment\"\n2:I[22016,[\"/_next/static/chunks/7c92e96509cd355e.js\",\"/_next/static/chunks/bbef3146f2d34722.js\"],\"\"]\n3:I[39756,[\"/_next/static/chunks/ff1a16fafef87110.js\",\"/_next/static/chunks/d2be314c3ece3fbe.js\"],\"default\"]\n4:I[37457,[\"/_next/static/chunks/ff1a16fafef87110.js\",\"/_next/static/chunks/d2be314c3ece3fbe.js\"],\"default\"]\n8:I[68027,[\"/_next/static/chunks/ff1a16fafef87110.js\",\"/_next/static/chunks/d2be314c3ece3fbe.js\"],\"default\"]\n:HL[\"/_next/static/chunks/9988c12a819fa1cb.css\",\"style\"]\n"])</script><script>self.__next_f.push([1,"0:{\"P\":null,\"b\":\"HS-IWVxCIkhkIanJO174r\",\"c\":[\"\",\"posts\",\"17.BeanPostProcessor\",\"\"],\"q\":\"\",\"i\":false,\"f\":[[[\"\",{\"children\":[\"posts\",{\"children\":[[\"slug\",\"17.BeanPostProcessor\",\"d\"],{\"children\":[\"__PAGE__\",{}]}]}]},\"$undefined\",\"$undefined\",true],[[\"$\",\"$1\",\"c\",{\"children\":[[[\"$\",\"link\",\"0\",{\"rel\":\"stylesheet\",\"href\":\"/_next/static/chunks/9988c12a819fa1cb.css\",\"precedence\":\"next\",\"crossOrigin\":\"$undefined\",\"nonce\":\"$undefined\"}],[\"$\",\"script\",\"script-0\",{\"src\":\"/_next/static/chunks/7c92e96509cd355e.js\",\"async\":true,\"nonce\":\"$undefined\"}]],[\"$\",\"html\",null,{\"lang\":\"zh-CN\",\"children\":[\"$\",\"body\",null,{\"className\":\"min-h-screen flex flex-col antialiased\",\"children\":[[\"$\",\"header\",null,{\"className\":\"border-b border-[var(--color-border)]\",\"children\":[\"$\",\"div\",null,{\"className\":\"max-w-2xl mx-auto px-5 h-12 flex items-center justify-between\",\"children\":[[\"$\",\"$L2\",null,{\"href\":\"/\",\"className\":\"font-mono text-sm font-semibold text-[var(--color-text)] hover:text-[var(--color-link)] transition-colors\",\"children\":\"一洼绿地\"}],[\"$\",\"nav\",null,{\"className\":\"flex items-center gap-5\",\"children\":[[[\"$\",\"$L2\",\"/\",{\"href\":\"/\",\"className\":\"text-sm text-[var(--color-text-secondary)] hover:text-[var(--color-text)] transition-colors\",\"children\":\"文章\"}],[\"$\",\"$L2\",\"/archives\",{\"href\":\"/archives\",\"className\":\"text-sm text-[var(--color-text-secondary)] hover:text-[var(--color-text)] transition-colors\",\"children\":\"归档\"}],[\"$\",\"$L2\",\"/tags\",{\"href\":\"/tags\",\"className\":\"text-sm text-[var(--color-text-secondary)] hover:text-[var(--color-text)] transition-colors\",\"children\":\"标签\"}],[\"$\",\"$L2\",\"/about\",{\"href\":\"/about\",\"className\":\"text-sm text-[var(--color-text-secondary)] hover:text-[var(--color-text)] transition-colors\",\"children\":\"关于\"}]],[\"$\",\"a\",null,{\"href\":\"https://github.com/koocyton\",\"target\":\"_blank\",\"rel\":\"noopener noreferrer\",\"className\":\"text-[var(--color-text-tertiary)] hover:text-[var(--color-text)] transition-colors\",\"children\":[\"$\",\"svg\",null,{\"className\":\"w-4 h-4\",\"fill\":\"currentColor\",\"viewBox\":\"0 0 24 24\",\"children\":[\"$\",\"path\",null,{\"d\":\"M12 0c-6.626 0-12 5.373-12 12 0 5.302 3.438 9.8 8.207 11.387.599.111.793-.261.793-.577v-2.234c-3.338.726-4.033-1.416-4.033-1.416-.546-1.387-1.333-1.756-1.333-1.756-1.089-.745.083-.729.083-.729 1.205.084 1.839 1.237 1.839 1.237 1.07 1.834 2.807 1.304 3.492.997.107-.775.418-1.305.762-1.604-2.665-.305-5.467-1.334-5.467-5.931 0-1.311.469-2.381 1.236-3.221-.124-.303-.535-1.524.117-3.176 0 0 1.008-.322 3.301 1.23.957-.266 1.983-.399 3.003-.404 1.02.005 2.047.138 3.006.404 2.291-1.552 3.297-1.23 3.297-1.23.653 1.653.242 2.874.118 3.176.77.84 1.235 1.911 1.235 3.221 0 4.609-2.807 5.624-5.479 5.921.43.372.823 1.102.823 2.222v3.293c0 .319.192.694.801.576 4.765-1.589 8.199-6.086 8.199-11.386 0-6.627-5.373-12-12-12z\"}]}]}]]}]]}]}],[\"$\",\"main\",null,{\"className\":\"flex-1\",\"children\":[\"$\",\"$L3\",null,{\"parallelRouterKey\":\"children\",\"error\":\"$undefined\",\"errorStyles\":\"$undefined\",\"errorScripts\":\"$undefined\",\"template\":[\"$\",\"$L4\",null,{}],\"templateStyles\":\"$undefined\",\"templateScripts\":\"$undefined\",\"notFound\":[[\"$\",\"div\",null,{\"className\":\"max-w-2xl mx-auto px-5 py-20 text-center\",\"children\":[[\"$\",\"h1\",null,{\"className\":\"font-mono text-4xl font-semibold text-[var(--color-text)] mb-2\",\"children\":\"404\"}],[\"$\",\"p\",null,{\"className\":\"text-sm text-[var(--color-text-tertiary)] mb-6\",\"children\":\"页面不存在\"}],[\"$\",\"$L2\",null,{\"href\":\"/\",\"className\":\"text-sm text-[var(--color-link)] hover:underline\",\"children\":\"← 返回首页\"}]]}],[]],\"forbidden\":\"$undefined\",\"unauthorized\":\"$undefined\"}]}],[\"$\",\"footer\",null,{\"className\":\"border-t border-[var(--color-border)] py-6\",\"children\":[\"$\",\"div\",null,{\"className\":\"max-w-2xl mx-auto px-5 text-xs text-[var(--color-text-tertiary)]\",\"children\":[\"© \",2026,\" koocyton\"]}]}]]}]}]]}],{\"children\":[[\"$\",\"$1\",\"c\",{\"children\":[null,[\"$\",\"$L3\",null,{\"parallelRouterKey\":\"children\",\"error\":\"$undefined\",\"errorStyles\":\"$undefined\",\"errorScripts\":\"$undefined\",\"template\":[\"$\",\"$L4\",null,{}],\"templateStyles\":\"$undefined\",\"templateScripts\":\"$undefined\",\"notFound\":\"$undefined\",\"forbidden\":\"$undefined\",\"unauthorized\":\"$undefined\"}]]}],{\"children\":[[\"$\",\"$1\",\"c\",{\"children\":[null,[\"$\",\"$L3\",null,{\"parallelRouterKey\":\"children\",\"error\":\"$undefined\",\"errorStyles\":\"$undefined\",\"errorScripts\":\"$undefined\",\"template\":[\"$\",\"$L4\",null,{}],\"templateStyles\":\"$undefined\",\"templateScripts\":\"$undefined\",\"notFound\":\"$undefined\",\"forbidden\":\"$undefined\",\"unauthorized\":\"$undefined\"}]]}],{\"children\":[[\"$\",\"$1\",\"c\",{\"children\":[\"$L5\",[[\"$\",\"script\",\"script-0\",{\"src\":\"/_next/static/chunks/bbef3146f2d34722.js\",\"async\":true,\"nonce\":\"$undefined\"}]],\"$L6\"]}],{},null,false,false]},null,false,false]},null,false,false]},null,false,false],\"$L7\",false]],\"m\":\"$undefined\",\"G\":[\"$8\",[]],\"S\":true}\n"])</script><script>self.__next_f.push([1,"9:I[97367,[\"/_next/static/chunks/ff1a16fafef87110.js\",\"/_next/static/chunks/d2be314c3ece3fbe.js\"],\"OutletBoundary\"]\na:\"$Sreact.suspense\"\nc:I[97367,[\"/_next/static/chunks/ff1a16fafef87110.js\",\"/_next/static/chunks/d2be314c3ece3fbe.js\"],\"ViewportBoundary\"]\ne:I[97367,[\"/_next/static/chunks/ff1a16fafef87110.js\",\"/_next/static/chunks/d2be314c3ece3fbe.js\"],\"MetadataBoundary\"]\n6:[\"$\",\"$L9\",null,{\"children\":[\"$\",\"$a\",null,{\"name\":\"Next.MetadataOutlet\",\"children\":\"$@b\"}]}]\n7:[\"$\",\"$1\",\"h\",{\"children\":[null,[\"$\",\"$Lc\",null,{\"children\":\"$Ld\"}],[\"$\",\"div\",null,{\"hidden\":true,\"children\":[\"$\",\"$Le\",null,{\"children\":[\"$\",\"$a\",null,{\"name\":\"Next.Metadata\",\"children\":\"$Lf\"}]}]}],null]}]\n"])</script><script>self.__next_f.push([1,"10:T7d2e,"])</script><script>self.__next_f.push([1,"\u003ch2\u003e前言\u003c/h2\u003e\n\u003cp\u003eBeanPostProcessor是一个工厂钩子，允许Spring框架在新创建Bean实例时对其进行定制化修改。例如：通过检查其标注的接口或者使用代理对其进行包裹。应用上下文会从Bean定义中自动检测出BeanPostProcessor并将它们应用到随后创建的任何Bean上。\u003c/p\u003e\n\u003cp\u003e普通Bean对象的工厂允许在程序中注册post-processors，应用到随后在本工厂中创建的所有Bean上。典型的场景如：post-processors使用postProcessBeforeInitialization方法通过特征接口或其他类似的方式来填充Bean；而为创建好的Bean创建代理则一般使用postProcessAfterInitialization方法。\u003c/p\u003e\n\u003cp\u003eBeanPostProcessor本身也是一个Bean，一般而言其实例化时机要早过普通的Bean，但是BeanPostProcessor也会依赖一些Bean，这就导致了一些Bean的实例化早于BeanPostProcessor，由此会导致一些问题。最近在处理shiro和spring cache整合时就碰到了，导致的结果就是spring cache不起作用。现将问题场景、查找历程及解决方法展现一下。\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e1 问题场景\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e打算在项目中将shiro与spring cache整合，使用spring cache统一管理缓存，也包括shiro认证时的用户信息查询。项目中将service分层，outter层负责权限和session，inner层主打事务和缓存并与DAO交互，两层之间也可以较容易的扩展为RPC或微服务模式。因此在shiro的authRealm中依赖了innerUserService，并在innerUserService中配置了spring cache的标注，使用cache进行缓存。配置如下（摘录重要部分）：\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-java\"\u003e\u003cspan class=\"hljs-meta\"\u003e@Bean(name=\"shiroFilter\")\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003epublic\u003c/span\u003e ShiroFilterFactoryBean \u003cspan class=\"hljs-title function_\"\u003eshiroFilter\u003c/span\u003e\u003cspan class=\"hljs-params\"\u003e(\n  \u003cspan class=\"hljs-meta\"\u003e@Qualifier(\"securityManager\")\u003c/span\u003e SecurityManager manager)\u003c/span\u003e {\n  ShiroFilterFactoryBean bean=\u003cspan class=\"hljs-keyword\"\u003enew\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eShiroFilterFactoryBean\u003c/span\u003e();\n  bean.setSecurityManager(manager);\n  ..............\n  \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e bean;\n}\n\n\u003cspan class=\"hljs-comment\"\u003e//配置核心安全事务管理器\u003c/span\u003e\n\u003cspan class=\"hljs-meta\"\u003e@Bean(name=\"securityManager\")\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003epublic\u003c/span\u003e SecurityManager \u003cspan class=\"hljs-title function_\"\u003esecurityManager\u003c/span\u003e\u003cspan class=\"hljs-params\"\u003e(\n                              \u003cspan class=\"hljs-meta\"\u003e@Qualifier(\"authRealm\")\u003c/span\u003e AuthorizingRealm authRealm,\n                              \u003cspan class=\"hljs-meta\"\u003e@Qualifier(\"sessionManager\")\u003c/span\u003e SessionManager sessionManager,\n                              \u003cspan class=\"hljs-meta\"\u003e@Qualifier(\"cookieRememberMeManager\")\u003c/span\u003e RememberMeManager rememberMeManager,\n                              \u003cspan class=\"hljs-meta\"\u003e@Qualifier(\"cacheManager\")\u003c/span\u003e CacheManager cacheManager)\u003c/span\u003e {\n  System.err.println(\u003cspan class=\"hljs-string\"\u003e\"--------------shiro已经加载----------------\"\u003c/span\u003e);\n  DefaultWebSecurityManager manager=\u003cspan class=\"hljs-keyword\"\u003enew\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eDefaultWebSecurityManager\u003c/span\u003e();\n  manager.setRealm(authRealm);\n  manager.setSessionManager(sessionManager);\n  manager.setRememberMeManager(rememberMeManager);\n  manager.setCacheManager(cacheManager);\n  \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e manager;\n}\n\n\u003cspan class=\"hljs-comment\"\u003e//配置自定义权限登录器\u003c/span\u003e\n\u003cspan class=\"hljs-meta\"\u003e@Bean(name=\"authRealm\")\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003epublic\u003c/span\u003e AuthorizingRealm \u003cspan class=\"hljs-title function_\"\u003eauthRealm\u003c/span\u003e\u003cspan class=\"hljs-params\"\u003e(IInnerUserService userService)\u003c/span\u003e {\n  \u003cspan class=\"hljs-type\"\u003eMyRealm\u003c/span\u003e \u003cspan class=\"hljs-variable\"\u003emyrealm\u003c/span\u003e \u003cspan class=\"hljs-operator\"\u003e=\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003enew\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eMyRealm\u003c/span\u003e(IInnerUserService);\n  logger.info(\u003cspan class=\"hljs-string\"\u003e\"authRealm myRealm initiated!\"\u003c/span\u003e);\n  \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e myrealm;\n}\n\n\u003cspan class=\"hljs-meta\"\u003e@Bean\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003epublic\u003c/span\u003e LifecycleBeanPostProcessor \u003cspan class=\"hljs-title function_\"\u003elifecycleBeanPostProcessor\u003c/span\u003e\u003cspan class=\"hljs-params\"\u003e()\u003c/span\u003e{\n  \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003enew\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eLifecycleBeanPostProcessor\u003c/span\u003e(Ordered.LOWEST_PRECEDENCE);\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e其中MyRealm是自定义的shiro AuthorizingRealm，用于执行认证与授权，其实现依赖innerUserService从库中查找用户信息，示例代码如下：\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-java\"\u003e\u003cspan class=\"hljs-keyword\"\u003epublic\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003eclass\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eMyRealm\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003eextends\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eAuthorizingRealm\u003c/span\u003e {\n\n  IInnerUserService userService;\n\n  \u003cspan class=\"hljs-keyword\"\u003epublic\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003eMyRealm\u003c/span\u003e\u003cspan class=\"hljs-params\"\u003e()\u003c/span\u003e{\n    \u003cspan class=\"hljs-built_in\"\u003esuper\u003c/span\u003e();\n  }\n\n  \u003cspan class=\"hljs-keyword\"\u003epublic\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003eMyRealm\u003c/span\u003e\u003cspan class=\"hljs-params\"\u003e(IInnerUserService userService)\u003c/span\u003e{\n    \u003cspan class=\"hljs-built_in\"\u003ethis\u003c/span\u003e.userService = userService;\n  }\n\n  \u003cspan class=\"hljs-keyword\"\u003epublic\u003c/span\u003e IInnerUserService \u003cspan class=\"hljs-title function_\"\u003egetUserService\u003c/span\u003e\u003cspan class=\"hljs-params\"\u003e()\u003c/span\u003e {\n    \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e userService;\n  }\n\n  \u003cspan class=\"hljs-keyword\"\u003epublic\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003evoid\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003esetUserService\u003c/span\u003e\u003cspan class=\"hljs-params\"\u003e(IInnerUserService userService)\u003c/span\u003e {\n    \u003cspan class=\"hljs-built_in\"\u003ethis\u003c/span\u003e.userService = userService;\n  }\n\n  \u003cspan class=\"hljs-meta\"\u003e@Override\u003c/span\u003e\n  \u003cspan class=\"hljs-keyword\"\u003eprotected\u003c/span\u003e AuthorizationInfo \u003cspan class=\"hljs-title function_\"\u003edoGetAuthorizationInfo\u003c/span\u003e\u003cspan class=\"hljs-params\"\u003e(\n    PrincipalCollection principals)\u003c/span\u003e {\n    \u003cspan class=\"hljs-comment\"\u003e//null usernames are invalid\u003c/span\u003e\n    \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (principals == \u003cspan class=\"hljs-literal\"\u003enull\u003c/span\u003e) {\n      \u003cspan class=\"hljs-keyword\"\u003ethrow\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003enew\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eAuthorizationException\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"PrincipalCollection method argument cannot be null.\"\u003c/span\u003e);\n    }\n\n    \u003cspan class=\"hljs-type\"\u003eSet\u003c/span\u003e \u003cspan class=\"hljs-variable\"\u003eroleNames\u003c/span\u003e \u003cspan class=\"hljs-operator\"\u003e=\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003enew\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eHashSet\u003c/span\u003e();\n    \u003cspan class=\"hljs-type\"\u003eSet\u003c/span\u003e \u003cspan class=\"hljs-variable\"\u003epermissions\u003c/span\u003e \u003cspan class=\"hljs-operator\"\u003e=\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003enew\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eHashSet\u003c/span\u003e();\n    \u003cspan class=\"hljs-type\"\u003eUser\u003c/span\u003e \u003cspan class=\"hljs-variable\"\u003euser\u003c/span\u003e \u003cspan class=\"hljs-operator\"\u003e=\u003c/span\u003e (User)getAvailablePrincipal(principals);\n    roleNames.add(\u003cspan class=\"hljs-string\"\u003e\"role1\"\u003c/span\u003e);\n    roleNames.add(\u003cspan class=\"hljs-string\"\u003e\"role2\"\u003c/span\u003e);\n    permissions.add(\u003cspan class=\"hljs-string\"\u003e\"user:create\"\u003c/span\u003e);\n    permissions.add(\u003cspan class=\"hljs-string\"\u003e\"user:update\"\u003c/span\u003e);\n    permissions.add(\u003cspan class=\"hljs-string\"\u003e\"user:delete\"\u003c/span\u003e);\n    \u003cspan class=\"hljs-type\"\u003eSimpleAuthorizationInfo\u003c/span\u003e \u003cspan class=\"hljs-variable\"\u003einfo\u003c/span\u003e \u003cspan class=\"hljs-operator\"\u003e=\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003enew\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eSimpleAuthorizationInfo\u003c/span\u003e(roleNames);\n    info.setStringPermissions(permissions);\n    \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e info;\n  }\n\n  \u003cspan class=\"hljs-meta\"\u003e@Override\u003c/span\u003e\n  \u003cspan class=\"hljs-keyword\"\u003eprotected\u003c/span\u003e AuthenticationInfo \u003cspan class=\"hljs-title function_\"\u003edoGetAuthenticationInfo\u003c/span\u003e\u003cspan class=\"hljs-params\"\u003e(AuthenticationToken token)\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003ethrows\u003c/span\u003e AuthenticationException {\n    \u003cspan class=\"hljs-type\"\u003eString\u003c/span\u003e \u003cspan class=\"hljs-variable\"\u003eusername\u003c/span\u003e \u003cspan class=\"hljs-operator\"\u003e=\u003c/span\u003e (String)token.getPrincipal(); \u003cspan class=\"hljs-comment\"\u003e//得到用户名\u003c/span\u003e\n    \u003cspan class=\"hljs-type\"\u003eString\u003c/span\u003e \u003cspan class=\"hljs-variable\"\u003epassword\u003c/span\u003e \u003cspan class=\"hljs-operator\"\u003e=\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003enew\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eString\u003c/span\u003e((\u003cspan class=\"hljs-type\"\u003echar\u003c/span\u003e[])token.getCredentials()); \u003cspan class=\"hljs-comment\"\u003e//得到密码\u003c/span\u003e\n    \u003cspan class=\"hljs-type\"\u003eUser\u003c/span\u003e \u003cspan class=\"hljs-variable\"\u003euser\u003c/span\u003e \u003cspan class=\"hljs-operator\"\u003e=\u003c/span\u003e userService.findByUsernameInner(username);\n    \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e(user==\u003cspan class=\"hljs-literal\"\u003enull\u003c/span\u003e){\n      \u003cspan class=\"hljs-keyword\"\u003ethrow\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003enew\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eUnknownAccountException\u003c/span\u003e();\n    }\n    \u003cspan class=\"hljs-keyword\"\u003eelse\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e(!password.equals(user.getPassword()))\n    {\n      \u003cspan class=\"hljs-keyword\"\u003ethrow\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003enew\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eIncorrectCredentialsException\u003c/span\u003e();\n    }\n    \u003cspan class=\"hljs-keyword\"\u003eelse\u003c/span\u003e{\n      \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003enew\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eSimpleAuthenticationInfo\u003c/span\u003e(user, password, getName());\n    }\n  }\n\n}\n\n而在innerUserService中配置了spring cache的标注，示例代码如下：\n\n```java\n\u003cspan class=\"hljs-meta\"\u003e@Service\u003c/span\u003e\n  \u003cspan class=\"hljs-keyword\"\u003epublic\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003eclass\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eIInnerUserServiceImpl\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003eimplements\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eIInnerUserService\u003c/span\u003e {\n  \u003cspan class=\"hljs-type\"\u003eLogger\u003c/span\u003e \u003cspan class=\"hljs-variable\"\u003elogger\u003c/span\u003e \u003cspan class=\"hljs-operator\"\u003e=\u003c/span\u003e LoggerFactory.getLogger(IInnerUserServiceImpl.class);\n\n  \u003cspan class=\"hljs-meta\"\u003e@Autowired\u003c/span\u003e\n  IUserDao userDao;\n\n  \u003cspan class=\"hljs-meta\"\u003e@Override\u003c/span\u003e\n  \u003cspan class=\"hljs-meta\"\u003e@Cacheable(value = \"mycache\", key = \"#username\")\u003c/span\u003e\n  \u003cspan class=\"hljs-keyword\"\u003epublic\u003c/span\u003e User \u003cspan class=\"hljs-title function_\"\u003efindByUsernameInner\u003c/span\u003e\u003cspan class=\"hljs-params\"\u003e(String username)\u003c/span\u003e {\n    \u003cspan class=\"hljs-type\"\u003eUser\u003c/span\u003e \u003cspan class=\"hljs-variable\"\u003euser\u003c/span\u003e \u003cspan class=\"hljs-operator\"\u003e=\u003c/span\u003e userDao.findByUsername(username);\n    logger.info(\u003cspan class=\"hljs-string\"\u003e\"Real execute find from database, username:{}\"\u003c/span\u003e, username);\n    \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e user;\n  }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e并在配置文件上标注了@EnableCaching(mode=AdviceMode.PROXY)以启动spring cache。这里不过多解释具体shiro和spring cache的使用，有兴趣的同学请自行搜索相关资料。\u003c/p\u003e\n\u003cp\u003e按理说这样的配置在认证的时候应该可以直接使用到innerUserService中配置的spring cache缓存。\u003c/p\u003e\n\u003cp\u003e但，问题出现了，当authRealm中依赖了innerUserService以后，定义在innerUserService上的spring cache就神奇的失效了。而authRealm不依赖innerUserService的时候，cache却运行的好好的。\u003c/p\u003e\n\u003cp\u003e接下来是问题查找的路径。\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\n\u003cp\u003e2 解决问题之旅\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e2.1 spring cache失效的表象原因\u003c/p\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e首先要找到spring cache失效的表象/直接原因，我们知道spring cache使用Spring AOP和拦截器的方式拦截定义了特定标注的方法，然后执行特定逻辑。因此其实现依赖于动态代理机制auto-proxy，而经过初步调试发现，当被authRealm依赖以后，innerUserService就不会被代理了，因此无从进入AOP的pointcut，也就是说AOP切面失效了！\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e2.2 从spring cache的集成机制分析深层次原因\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e为何没有被代理呢，我们先来确认一下正常情况下什么时候进行代理封装，这时关于BeanPostProcessor的定义浮现脑海，据文档记载BeanPostProcessor允许在Bean实例化的前后对其做一些猥琐的事情，比如代理。我们在BeanPostProcessor的实现类中发现了InstantiationAwareBeanPostProcessor、SmartInstantiationAwareBeanPostProcessor、AbstractAutoProxyCreator、InfrastructureAdvisorAutoProxyCreator这一脉。而反观@enableCache标注在启动的时候会@import CachingConfigurationSelector，其selectImports方法会返回AutoProxyRegistrar和ProxyCachingConfiguration的全类名（我们定义了mode=AdviceMode.PROXY），也就是加载这两个类。第一个的作用就是注册InfrastructureAdvisorAutoProxyCreator到BeanDefinitionRegistry中。第二个的作用就是注册了BeanFactoryCacheOperationSourceAdvisor和CacheInterceptor。\u003c/p\u003e\n\u003cp\u003e因此，当正常情况下，一个添加了spring cache相关标注的bean会在创建后被InfrastructureAdvisorAutoProxyCreator基于advisor进行代理增强，代理后便可在拦截器CacheInterceptor中对其方法进行拦截，然后执行cache相关逻辑。此处省略具体处理逻辑，有兴趣请参考相关文档。\u003c/p\u003e\n\u003cp\u003e所以第一怀疑就是innerUserService没有经过InfrastructureAdvisorAutoProxyCreator的代理增强。果然调试发现，被authRealm依赖的情况下在InnerUserService的Bean实例化时，用于处理该Bean的PostBeanProcessor明显比没被authRealm依赖时少，并且不含有InfrastructureAdvisorAutoProxyCreator。\u003c/p\u003e\n\u003cp\u003e而且，被依赖时会多打出来一行信息：\u003c/p\u003e\n\u003cp\u003e...................\u003c/p\u003e\n\u003cp\u003eBean 'IInnerUserServiceImpl' of type [shiro.web.inner.service.impl.IInnerUserServiceImpl] is not eligible for getting processed by all BeanPostProcessors (for example: not eligible for auto-proxying)\u003c/p\u003e\n\u003cp\u003e...................\u003c/p\u003e\n\u003cp\u003e据此推断，可能是innerUserService启动时机过早，导致的后面那些BeanPostProcessor们来没来得及实例化及注册呢。\u003c/p\u003e\n\u003cp\u003e2.3 BeanPostProcessor启动阶段对其依赖的Bean造成的影响\u003c/p\u003e\n\u003cp\u003e首先确认了authRealm也是受害者，因为shiroFilter-\u003eSecurityManager-\u003eauthRealm的依赖关系导致其不得不提前实例化。表面上的罪魁祸首是shiroFilter，但是到底是谁导致的shiroFilter预料之外的提前启动呢。shiroFilter与InfrastructureAdvisorAutoProxyCreator的具体启动时机到底是什么时候呢。\u003c/p\u003e\n\u003cp\u003e又经过一番混天暗地的调试，终于了解了BeanPostProcessor的启动时机。在AbstractBeanFactory中维护了BeanPostProcessor的列表：\u003c/p\u003e\n\u003cp\u003eprivate final List beanPostProcessors = new ArrayList();\u003c/p\u003e\n\u003cp\u003e并实现了ConfigurableBeanFactory定义的方法：\u003c/p\u003e\n\u003cp\u003evoid addBeanPostProcessor(BeanPostProcessor beanPostProcessor);\u003c/p\u003e\n\u003cp\u003e因此我们首先监控AbstractBeanFactory.addBeanPostProcessor()，看看启动过程中谁调用了该方法来注册BeanPostProcessor。发现实例化及注册PostBeanFactory的阶段分为四个：\u003c/p\u003e\n\u003cp\u003e第一阶段是在启动时调用过程会调用AbstractApplicationContext.refresh()，其中的prepareBeanFactory方法中注册了\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-java\"\u003eApplicationContextAwareProcessor、ApplicationListenerDetector：\n\n........\n\nbeanFactory.addBeanPostProcessor(\u003cspan class=\"hljs-keyword\"\u003enew\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eApplicationContextAwareProcessor\u003c/span\u003e(\u003cspan class=\"hljs-built_in\"\u003ethis\u003c/span\u003e));\n\n........\n\nbeanFactory.addBeanPostProcessor(\u003cspan class=\"hljs-keyword\"\u003enew\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eApplicationListenerDetector\u003c/span\u003e(\u003cspan class=\"hljs-built_in\"\u003ethis\u003c/span\u003e));\n\n........\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e然后在postProcessBeanFactory方法中注册了WebApplicationContextServletContextAwareProcessor：\u003c/p\u003e\n\u003cp\u003ebeanFactory.addBeanPostProcessor(\u003c/p\u003e\n\u003cp\u003enew WebApplicationContextServletContextAwareProcessor(this));\u003c/p\u003e\n\u003cp\u003e然后在invokeBeanFactoryPostProcessors方法中调用\u003c/p\u003e\n\u003cp\u003e复制代码 代码如下:\u003c/p\u003e\n\u003cp\u003ePostProcessorRegistrationDelegate.invokeBeanFactoryPostProcessors(beanFactory, getBeanFactoryPostProcessors());\u003c/p\u003e\n\u003cp\u003e其中对已经注册的BeanFactoryPostProcessors挨个调用其postProcessBeanFactory方法，其中有一个ConfigurationClassPostProcessor，其postProcessBeanFactory方法中注册了一个\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-java\"\u003eImportAwareBeanPostProcessor：\nbeanFactory.addBeanPostProcessor(\u003cspan class=\"hljs-keyword\"\u003enew\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eImportAwareBeanPostProcessor\u003c/span\u003e(beanFactory));\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e最后在registerBeanPostProcessors方法中调用\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-java\"\u003ePostProcessorRegistrationDelegate.registerBeanPostProcessors(beanFactory, \u003cspan class=\"hljs-built_in\"\u003ethis\u003c/span\u003e);\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e在该方法中，首先注册BeanPostProcessorChecker：\u003c/p\u003e\n\u003cp\u003e复制代码 代码如下:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-java\"\u003ebeanFactory.addBeanPostProcessor(\u003cspan class=\"hljs-keyword\"\u003enew\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eBeanPostProcessorChecker\u003c/span\u003e(beanFactory, beanProcessorTargetCount));\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e该BeanPostProcessorChecker就是输出上面那行信息的真凶，它会在Bean创建完后检查可在当前Bean上起作用的BeanPostProcessor个数与总的BeanPostProcessor个数，如果起作用的个数少于总数，则报出上面那句信息。\u003c/p\u003e\n\u003cp\u003e然后分成三个阶段依次实例化并注册实现了PriorityOrdered的BeanPostProcessor、实现了Ordered的BeanPostProcessor、没实现Ordered的BeanPostProcessor，代码如下：\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-java\"\u003e\u003cspan class=\"hljs-comment\"\u003e// Separate between BeanPostProcessors that implement PriorityOrdered,\u003c/span\u003e\n\u003cspan class=\"hljs-comment\"\u003e// Ordered, and the rest.\u003c/span\u003e\n\u003cspan class=\"hljs-type\"\u003eList\u003c/span\u003e \u003cspan class=\"hljs-variable\"\u003epriorityOrderedPostProcessors\u003c/span\u003e \u003cspan class=\"hljs-operator\"\u003e=\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003enew\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eArrayList\u003c/span\u003e();\n\u003cspan class=\"hljs-type\"\u003eList\u003c/span\u003e \u003cspan class=\"hljs-variable\"\u003einternalPostProcessors\u003c/span\u003e \u003cspan class=\"hljs-operator\"\u003e=\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003enew\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eArrayList\u003c/span\u003e();\n\u003cspan class=\"hljs-type\"\u003eList\u003c/span\u003e \u003cspan class=\"hljs-variable\"\u003eorderedPostProcessorNames\u003c/span\u003e \u003cspan class=\"hljs-operator\"\u003e=\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003enew\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eArrayList\u003c/span\u003e();\n\u003cspan class=\"hljs-type\"\u003eList\u003c/span\u003e \u003cspan class=\"hljs-variable\"\u003enonOrderedPostProcessorNames\u003c/span\u003e \u003cspan class=\"hljs-operator\"\u003e=\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003enew\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eArrayList\u003c/span\u003e();\n\u003cspan class=\"hljs-keyword\"\u003efor\u003c/span\u003e (String ppName : postProcessorNames) {\n  \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (beanFactory.isTypeMatch(ppName, PriorityOrdered.class)) {\n    \u003cspan class=\"hljs-type\"\u003eBeanPostProcessor\u003c/span\u003e \u003cspan class=\"hljs-variable\"\u003epp\u003c/span\u003e \u003cspan class=\"hljs-operator\"\u003e=\u003c/span\u003e beanFactory.getBean(ppName, BeanPostProcessor.class);\n    priorityOrderedPostProcessors.add(pp);\n    \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (pp \u003cspan class=\"hljs-keyword\"\u003einstanceof\u003c/span\u003e MergedBeanDefinitionPostProcessor) {\n      internalPostProcessors.add(pp);\n    }\n  }\n  \u003cspan class=\"hljs-keyword\"\u003eelse\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (beanFactory.isTypeMatch(ppName, Ordered.class)) {\n    orderedPostProcessorNames.add(ppName);\n  }\n  \u003cspan class=\"hljs-keyword\"\u003eelse\u003c/span\u003e {\n    nonOrderedPostProcessorNames.add(ppName);\n  }\n}\n\n\u003cspan class=\"hljs-comment\"\u003e// First, register the BeanPostProcessors that implement PriorityOrdered.\u003c/span\u003e\n\nsortPostProcessors(priorityOrderedPostProcessors, beanFactory);\n\nregisterBeanPostProcessors(beanFactory, priorityOrderedPostProcessors);\n\n\u003cspan class=\"hljs-comment\"\u003e// Next, register the BeanPostProcessors that implement Ordered.\u003c/span\u003e\n\n\u003cspan class=\"hljs-type\"\u003eList\u003c/span\u003e \u003cspan class=\"hljs-variable\"\u003eorderedPostProcessors\u003c/span\u003e \u003cspan class=\"hljs-operator\"\u003e=\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003enew\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eArrayList\u003c/span\u003e();\n\n\u003cspan class=\"hljs-keyword\"\u003efor\u003c/span\u003e (String ppName : orderedPostProcessorNames) {\n\n  \u003cspan class=\"hljs-type\"\u003eBeanPostProcessor\u003c/span\u003e \u003cspan class=\"hljs-variable\"\u003epp\u003c/span\u003e \u003cspan class=\"hljs-operator\"\u003e=\u003c/span\u003e beanFactory.getBean(ppName, BeanPostProcessor.class);\n\n  orderedPostProcessors.add(pp);\n\n  \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (pp \u003cspan class=\"hljs-keyword\"\u003einstanceof\u003c/span\u003e MergedBeanDefinitionPostProcessor) {\n\n    internalPostProcessors.add(pp);\n\n  }\n\n}\n\nsortPostProcessors(orderedPostProcessors, beanFactory);\n\nregisterBeanPostProcessors(beanFactory, orderedPostProcessors);\n\n\u003cspan class=\"hljs-comment\"\u003e// Now, register all regular BeanPostProcessors.\u003c/span\u003e\n\n\u003cspan class=\"hljs-type\"\u003eList\u003c/span\u003e \u003cspan class=\"hljs-variable\"\u003enonOrderedPostProcessors\u003c/span\u003e \u003cspan class=\"hljs-operator\"\u003e=\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003enew\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eArrayList\u003c/span\u003e();\n\n\u003cspan class=\"hljs-keyword\"\u003efor\u003c/span\u003e (String ppName : nonOrderedPostProcessorNames) {\n\n  \u003cspan class=\"hljs-type\"\u003eBeanPostProcessor\u003c/span\u003e \u003cspan class=\"hljs-variable\"\u003epp\u003c/span\u003e \u003cspan class=\"hljs-operator\"\u003e=\u003c/span\u003e beanFactory.getBean(ppName, BeanPostProcessor.class);\n\n  nonOrderedPostProcessors.add(pp);\n\n  \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (pp \u003cspan class=\"hljs-keyword\"\u003einstanceof\u003c/span\u003e MergedBeanDefinitionPostProcessor) {\n\n    internalPostProcessors.add(pp);\n\n  }\n\n}\n\nregisterBeanPostProcessors(beanFactory, nonOrderedPostProcessors);\n\n\u003cspan class=\"hljs-comment\"\u003e// Finally, re-register all internal BeanPostProcessors.\u003c/span\u003e\n\nsortPostProcessors(internalPostProcessors, beanFactory);\n\nregisterBeanPostProcessors(beanFactory, internalPostProcessors);\n\n\u003cspan class=\"hljs-comment\"\u003e// Re-register post-processor for detecting inner beans as ApplicationListeners,\u003c/span\u003e\n\n\u003cspan class=\"hljs-comment\"\u003e// moving it to tCuyNowSqhe end of the processor chain (for picking up proxies etc).\u003c/span\u003e\n\nbeanFactory.addBeanPostProcessor(\u003cspan class=\"hljs-keyword\"\u003enew\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eApplicationListenerDetector\u003c/span\u003e(applicationContext));\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e需要注意的是，除了第一个阶段，其他阶段同一个阶段的BeanPostProcessor是在全部实例化完成以后才会统一注册到beanFactory的，因此，同一个阶段的BeanPostProcessor及其依赖的Bean在实例化的时候是无法享受到相同阶段但是先实例化的BeanPostProcessor的“服务”的，因为它们还没有注册。\u003c/p\u003e\n\u003cp\u003e从上面调试与源代码分析，BeanPostProcessor的实例化与注册分为四个阶段，第一阶段applicationContext内置阶段、第二阶段priorityOrdered阶段、第三阶段Ordered阶段、第四阶段nonOrdered阶段。而BeanPostProcessor同时也是Bean，其注册之前一定先实例化。而且是分批实例化和注册，也就是属于同一批的BeanPostProcesser全部实例化完成后，再全部注册，不存在先实例化先注册的问题。而在实例化的时候其依赖的Bean同样要先实例化。\u003c/p\u003e\n\u003cp\u003e因此导致一个结果就是，被PriorityOrderedBeanPostProcessor所依赖的Bean其初始化时无法享受到PriorityOrdered、Ordered、和nonOrdered的BeanPostProcessor的服务。而被OrderedBeanPostProcessor所依赖的Bean无法享受Ordered、和nonOrdered的BeanPostProcessor的服务。最后被nonOrderedBeanPostProcessor所依赖的Bean无法享受到nonOrderedBeanPostProcessor的服务。\u003c/p\u003e\n\u003cp\u003e由于InfrastructureAdvisorAutoProxyCreator的启动阶段是Ordered，因此我们需要确保没有任何priorityOrdered和Ordered的BeanPostProcessor直接或间接的依赖到shiroFilter，也就是依赖到我们的innerUserService。\u003c/p\u003e\n\u003cp\u003e同时，在PriorityOrdered接口的注解中也提到了该情况：\u003c/p\u003e\n\u003cp\u003eNote: {@code PriorityOrdered} post-processor beans are initialized in\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\n\u003cp\u003ea special phase, ahead of other post-processor beans. This subtly\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003eaffects their auhttp://towiring behavior: they will only be autowired against\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003ebeans which do not require eager initialization for type matching.\u003c/p\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e2.4 BeanPostProcessor在进行依赖的Bean注入时，根据Bean名称进行类型检查时导致的“误伤”\u003c/p\u003e\n\u003cp\u003eOK，问题貌似已查明，修改Configuration中所有PriorityOrdered和Ordered类型的PostBeanProcessor的Bean配置，使其不再依赖shiroFilter。再次启动，却发现仍然提前启动了shiroFilter-\u003eSecurityManager-\u003eauthRealm-\u003einnerUserService。\u003c/p\u003e\n\u003cp\u003e百思不得其解，又是一轮昏天暗地的调试，查找shiroFilter具体的启动时机。发现在一个叫做dataSourceInitializerPostProcessor的BeanPostProcessor实例化的时候，在根据类型获得其依赖的参数时，对shiroFilter执行了初始化。导致后续SecurityManager-\u003eauthRealm-\u003einnerUserService统统提前初始化。但是在dataSourceInitializerPostProcessor之前的BeanPostProcessor却没有。经调试它们是否会导致shiroFilter初始化的区别在调用AbstractBeanFactory.isTypeMatch方法时出现：\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-java\"\u003e\u003cspan class=\"hljs-keyword\"\u003epublic\u003c/span\u003e \u003cspan class=\"hljs-type\"\u003eboolean\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003eisTypeMatch\u003c/span\u003e\u003cspan class=\"hljs-params\"\u003e(String name, ResolvableType typeToMatch)\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003ethrows\u003c/span\u003e NoSuchBeanDefinitionException{\n\n.....................\n\n\u003cspan class=\"hljs-comment\"\u003e// Check bean class whether we're dealing with a FactoryBean.\u003c/span\u003e\n\n\u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (FactoryBean.class.isAssignableFrom(beanType)) { \u003cspan class=\"hljs-comment\"\u003e//（1）判断名称对应的Bean是否是一个FactoryBean，若是FactoryBean才执行本句\u003c/span\u003e\n\n\u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (!BeanFactoryUtils.isFactoryDereference(name)) {\n\n\u003cspan class=\"hljs-comment\"\u003e// If it's a FactoryBean, we want to look at what it creates, not the factory class.\u003c/span\u003e\n\nbeanType = getTypeForFactoryBean(beanName, mbd);\n\n\u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (beanType == \u003cspan class=\"hljs-literal\"\u003enull\u003c/span\u003e) {\n\n\u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e \u003cspan class=\"hljs-literal\"\u003efalse\u003c/span\u003e;\n\n}\n\n}\n\n}\n\n.....................\n\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e然后进入AbstractAutowireCapableBeanFactory.getTypeForFactoryBean方法：\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-java\"\u003e\u003cspan class=\"hljs-meta\"\u003e@Override\u003c/span\u003e\n\n\u003cspan class=\"hljs-keyword\"\u003eprotected\u003c/span\u003e Class\u003e getTypeForFactoryBean(String beanName, RootBeanDefinition mbd) {\n\n\u003cspan class=\"hljs-type\"\u003eString\u003c/span\u003e \u003cspan class=\"hljs-variable\"\u003efactoryBeanName\u003c/span\u003e \u003cspan class=\"hljs-operator\"\u003e=\u003c/span\u003e mbd.getFactoryBeanName();\n\n\u003cspan class=\"hljs-type\"\u003eString\u003c/span\u003e \u003cspan class=\"hljs-variable\"\u003efactoryMethodName\u003c/span\u003e \u003cspan class=\"hljs-operator\"\u003e=\u003c/span\u003e mbd.getFactoryMethodName();\n\n\u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (factoryBeanName != \u003cspan class=\"hljs-literal\"\u003enull\u003c/span\u003e) {\n\n\u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (factoryMethodName != \u003cspan class=\"hljs-literal\"\u003enull\u003c/span\u003e) {\n\n\u003cspan class=\"hljs-comment\"\u003e// Try to obtain the FactoryBean's object type from its factory method declaration\u003c/span\u003e\n\n\u003cspan class=\"hljs-comment\"\u003e// without instantiating the containing bean at all.\u003c/span\u003e\n\nBeanDefihttp:\u003cspan class=\"hljs-comment\"\u003e//nition fbDef = getBeanDefinition(factoryBeanName);\u003c/span\u003e\n\n\u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (fbDef \u003cspan class=\"hljs-keyword\"\u003einstanceof\u003c/span\u003e AbstractBeanDefinition) {\n\n\u003cspan class=\"hljs-type\"\u003eAbstractBeanDefinition\u003c/span\u003e \u003cspan class=\"hljs-variable\"\u003eafbDef\u003c/span\u003e \u003cspan class=\"hljs-operator\"\u003e=\u003c/span\u003e (AbstractBeanDefinition) fbDef;\n\n\u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (afbDef.hasBeanClass()) {\n\nClass\u003e result = getTypeForFactoryBeanFromMethod(afbDef.getBeanClass(), factoryMethodName);\n\n\u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (result != \u003cspan class=\"hljs-literal\"\u003enull\u003c/span\u003e) {\n\n\u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e result;\n\n}\n\n}\n\n}\n\n}\n\n\u003cspan class=\"hljs-comment\"\u003e// If not resolvable above and the referenced factory bean doesn't exist yet,\u003c/span\u003e\n\n\u003cspan class=\"hljs-comment\"\u003e// exit here - we don't want to force the creation of another bean just to\u003c/span\u003e\n\n\u003cspan class=\"hljs-comment\"\u003e// obtain a FactoryBean's object type...\u003c/span\u003e\n\n\u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (!isBeanEligibleForMetadataCaching(factoryBeanName)) { \u003cspan class=\"hljs-comment\"\u003e//（2）判断该bean对应的factoryBeanName是否已经初始化了，如果没有，就返回。如果有，则继续\u003c/span\u003e\n\n\u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e \u003cspan class=\"hljs-literal\"\u003enull\u003c/span\u003e;\n\n}\n\n}\n\n\u003cspan class=\"hljs-comment\"\u003e// Let's obtain a shortcut instance for an early getObjectType() call...\u003c/span\u003e\n\nFactoryBean\u003e fb = (mbd.isSingleton() ?\n\ngetSingletonFactoryBeanForTypeCheck(beanName, mbd) :\n\ngetNonSingletonFactoryBeanForTypeCheck(beanName, mbd));\n\n......................\n\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e其中，有一个重要的判断：\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-java\"\u003e\u003cspan class=\"hljs-comment\"\u003e// If not resolvable above and the referenced factory bean doesn't exist yet,\u003c/span\u003e\n\n\u003cspan class=\"hljs-comment\"\u003e// exit here - we don't want to force the creation of another bean just to\u003c/span\u003e\n\n\u003cspan class=\"hljs-comment\"\u003e// obtain a FactoryBean's object type...\u003c/span\u003e\n\n\u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (!isBeanEligibleForMetadataCaching(factoryBeanName)) {\n\n\u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e \u003cspan class=\"hljs-literal\"\u003enull\u003c/span\u003e;\n\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e注解说的很明确，如果名字对应的factoryBean所在的factoryBean工厂尚未解析并实例化，那就直接退出，不会强制创建该facotryBean工厂，也就是Configuration对应的Bean。再次调试，果然发现，在先前的BeanPostProcessor和dataSourceInitializerPostProcessor之间，存在一个lifecycleBeanPostProcessor，而lifecycleBeanPostProcessor是在我们的Configuration中显示定义的，因此，当lifecycleBeanPostProcessor启动时会导致Configuration实例化。\u003c/p\u003e\n\u003cp\u003edataSourceInitializerPostProcessor和在它之前的BeanPostProcessor对shiroFilter行为的不同在这里得到了完美的解释。本质上说dataSourceInitializerPostProcessor并不重要，重要的是lifecycleBeanPostProcessor将Configuration初始化了。就算不是dataSourceInitializerPostProcessor，那另一个BeanPostProcessor实例化时同样会将shiroFilter初始化。\u003c/p\u003e\n\u003cp\u003e最终隐藏大BOSS查明，解决方案就简单了，将lifecycleBeanPostProcessor移出到一个单独的Configuration就好了。\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e总结\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003e3.1 BeanPostProcessor启动顺序，以及其对于依赖的Bean的影响\u003c/p\u003e\n\u003cp\u003eBeanPostProcessor的启动时机。分为四个阶段，第一阶段context内置阶段、第二阶段priorityOrdered阶段、第三阶段Ordered阶段、第四阶段nonOrdered阶段。\u003c/p\u003e\n\u003cp\u003e而BeanPostProcessor同时也是Bean，其注册之前一定先实例化。而且是分批实例化和注册，也就是属于同一批的BeanPostProcesser全部实例化完成后，再全部注册，不存在先实例化先注册的问题。而在实例化的时候其依赖的Bean同样要先实例化。\u003c/p\u003e\n\u003cp\u003e因此导致一个结果就是，被PriorityOrderedBeanPostProcessor所依赖的Bean其初始化以后无法享受到PriorityOrdered、Ordered、和nonOrdered的BeanPostProcessor的服务。而被OrderedBeanPostProcessor所依赖的Bean无法享受Ordered、和nonOrdered的BeanPostProcessor的服务。最后被nonOrderedBeanPostProcessor所依赖的Bean无法享受到nonOrderedBeanPostProcessor的服务。\u003c/p\u003e\n\u003cp\u003e3.2 注意避免BeanPostProcessor启动时的“误伤”陷阱\u003c/p\u003e\n\u003cp\u003eBeanPostProcessor实例化时，自动依赖注入根据类型获得需要注入的Bean时，会将某些符合条件的Bean（FactoryBean并且其FactoryBeanFactory已经实例化的）先实例化，如果此FacotryBean又依赖其他普通Bean，会导致该Bean提前启动，造成误伤（无法享受部分BeanPostProcessor的后处理，例如典型的auto-proxy）。\u003c/p\u003e"])</script><script>self.__next_f.push([1,"5:[\"$\",\"article\",null,{\"className\":\"max-w-2xl mx-auto px-5 py-10\",\"children\":[[\"$\",\"header\",null,{\"className\":\"mb-8\",\"children\":[[\"$\",\"h1\",null,{\"className\":\"font-mono text-xl font-semibold text-[var(--color-text)] leading-tight\",\"children\":\"浅谈BeanPostProcessor加载次序及其对Bean造成的影响分析\"}],[\"$\",\"div\",null,{\"className\":\"flex items-center gap-3 mt-2 text-xs text-[var(--color-text-tertiary)] font-mono\",\"children\":[[\"$\",\"time\",null,{\"dateTime\":\"2024-03-28\",\"children\":\"2024-03-28\"}],[\"$\",\"span\",null,{\"children\":\"·\"}],[\"$\",\"span\",null,{\"children\":\"18 min read\"}]]}],[\"$\",\"div\",null,{\"className\":\"flex flex-wrap gap-1.5 mt-3\",\"children\":[[\"$\",\"$L2\",\"flutter\",{\"href\":\"/tags/flutter\",\"className\":\"text-xs font-mono text-[var(--color-text-tertiary)] hover:text-[var(--color-link)] transition-colors\",\"children\":[\"#\",\"flutter\"]}],[\"$\",\"$L2\",\"app\",{\"href\":\"/tags/app\",\"className\":\"text-xs font-mono text-[var(--color-text-tertiary)] hover:text-[var(--color-link)] transition-colors\",\"children\":[\"#\",\"app\"]}]]}]]}],[\"$\",\"div\",null,{\"className\":\"prose\",\"dangerouslySetInnerHTML\":{\"__html\":\"$10\"}}],\"$L11\",\"$L12\"]}]\n"])</script><script>self.__next_f.push([1,"13:I[31175,[\"/_next/static/chunks/7c92e96509cd355e.js\",\"/_next/static/chunks/bbef3146f2d34722.js\"],\"default\"]\n11:[\"$\",\"$L13\",null,{}]\n12:[\"$\",\"footer\",null,{\"className\":\"mt-8 pt-4 border-t border-[var(--color-border)]\",\"children\":[\"$\",\"$L2\",null,{\"href\":\"/\",\"className\":\"text-sm text-[var(--color-link)] hover:underline\",\"children\":\"← 返回\"}]}]\n"])</script><script>self.__next_f.push([1,"d:[[\"$\",\"meta\",\"0\",{\"charSet\":\"utf-8\"}],[\"$\",\"meta\",\"1\",{\"name\":\"viewport\",\"content\":\"width=device-width, initial-scale=1\"}]]\n"])</script><script>self.__next_f.push([1,"14:I[27201,[\"/_next/static/chunks/ff1a16fafef87110.js\",\"/_next/static/chunks/d2be314c3ece3fbe.js\"],\"IconMark\"]\nb:null\nf:[[\"$\",\"title\",\"0\",{\"children\":\"浅谈BeanPostProcessor加载次序及其对Bean造成的影响分析 - 一洼绿地\"}],[\"$\",\"meta\",\"1\",{\"name\":\"description\",\"content\":\"浅谈BeanPostProcessor加载次序及其对Bean造成的影响分析\"}],[\"$\",\"meta\",\"2\",{\"name\":\"keywords\",\"content\":\"javascript java php emacs spring linux flutter\"}],[\"$\",\"link\",\"3\",{\"rel\":\"icon\",\"href\":\"/img/avatar/favicon.png\"}],[\"$\",\"$L14\",\"4\",{}]]\n"])</script></body></html>